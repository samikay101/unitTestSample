
---

# ðŸ“˜ How to Run Tests in a CI/CD Pipeline using VSTest in Azure DevOps

This guide provides a **step-by-step walkthrough** for setting up automated tests in your CI/CD pipeline using the built-in `VSTest@3` task in Azure DevOps.

---

## ðŸ¤” What is `VSTest@3`?

`VSTest@3` is an Azure DevOps Pipelines task that runs automated tests as part of your CI/CD workflow. It leverages Microsoft's `VSTest.Console.exe` to execute unit tests in Visual Studio projects.

In a CI/CD context, `VSTest@3` provides:

- âœ… **Automatic discovery of test DLLs** (using wildcards such as `*Tests.dll`)
- âœ… **Remote test execution** on both hosted and self-hosted build agents
- âœ… **Generation of detailed test reports** in the `.trx` format that integrate with Azure DevOps reporting
- âœ… **Advanced configurations** including:
  - Parallel test execution
  - Filtering or excluding specific tests
  - Collecting code coverage data
  - Diagnostic logging

---

## ðŸ“Œ How is `VSTest@3` Different from `dotnet test`?

The following table compares features between `dotnet test` (typically used in VS Code) and `VSTest@3` (designed for Azure DevOps):

| **Feature**                           | `dotnet test` (VS Code)            | `VSTest@3` (Azure DevOps)                           |
|---------------------------------------|------------------------------------|----------------------------------------------------|
| âœ… **Runs tests?**                     | Yes                                | Yes                                                |
| ðŸš« **Runs in CI/CD?**                  | No (intended for local development)| Yes (specifically for pipelines)                   |
| âœ… **Automatically finds tests?**      | Yes                                | No (requires specifying `*Tests.dll`)              |
| ðŸš« **Generates test reports?**         | No (by default)                    | Yes (produces `.trx` reports for Azure DevOps)       |
| âš ï¸ **Can exclude tests?**              | Limited options                    | Yes (supports `testFiltercriteria`)                |
| ðŸš« **Supports code coverage?**         | No (by default)                    | Yes (`codeCoverageEnabled: true`)                  |
| âš ï¸ **Supports parallel execution?**    | Limited                            | Yes                                                |

---

## Step 1: ðŸ—‚ï¸ Organize Your Repository Structure

A well-structured repository is essential for maintainability and testability. Below are some guidelines for organizing your projects.

### ðŸ”§ Project Layout Guidelines

- **Separate projects:** Keep your Logic App project and Unit Test project in distinct directories.

```plaintext
â”œâ”€â”€ MyLogicApp/                      # Azure Logic App Standard project
â”‚   â”œâ”€â”€ .vscode/                    
â”‚   â”œâ”€â”€ Artifacts/                  
â”‚   â”œâ”€â”€ lib/                        
â”‚   â”œâ”€â”€ MyWorkflowSample/           # Workflow definitions folder
â”‚   â”‚   â””â”€â”€ workflow.json           # Workflow JSON (triggers, actions, etc.)
â”‚   â”œâ”€â”€ workflow-designtime/       
â”‚   â”‚   â”œâ”€â”€ host.json               
â”‚   â”‚   â””â”€â”€ local.settings.json     
â”‚   â”œâ”€â”€ .funcignore                 
â”‚   â”œâ”€â”€ .gitignore                  
â”‚   â”œâ”€â”€ connections.json            
â”‚   â”œâ”€â”€ host.json                   
â”‚   â”œâ”€â”€ local.settings.json         
â”‚   â””â”€â”€ parameters.json             
â”œâ”€â”€ Tests/                           # Unit and integration test project
â”‚   â”œâ”€â”€ MyLogicAppTestProject/       # Main test project folder
â”‚   â”‚   â”œâ”€â”€ bin/                     # Compiled binary output (autogenerated)
â”‚   â”‚   â”œâ”€â”€ obj/                     # Intermediate build files (autogenerated)
â”‚   â”‚   â”œâ”€â”€ MySampleWorkflow/        # Grouping tests for a specific workflow
â”‚   â”‚   â”‚   â””â”€â”€ MockOutputs/         # Contains mock data for test execution
â”‚   â”‚   â”‚   â””â”€â”€ MyWorkflowTest.cs    # C# test class for workflow testing
â”‚   â”œâ”€â”€ TestExecutor.cs              # Shared utility for executing tests
â”‚   â”œâ”€â”€ MyLogicAppTestProject.csproj # Project file for the test project
â”‚   â””â”€â”€ Tests.sln                    # Visual Studio solution file for tests
â”œâ”€â”€ deployments/                     # CI/CD deployment folder
â”‚   â”œâ”€â”€ MyLogicAppDeployment/        # Deployment artifacts for the Logic App
â”‚   â”‚   â”œâ”€â”€ pipelines/               # CI/CD pipeline definitions
â”‚   â”‚   â”‚   â””â”€â”€ CI-Pipeline.yml      # Pipeline configuration file
```

> **Note:** Ensure that the unit test project (e.g., `MyLogicApp.Tests`) references the main Logic App project to access workflow definitions and shared components.

### ðŸ“ Add Deployment and Pipeline Structure

In the root directory of your repository:

1. **Create a `deployments/` folder** to store all DevOps-related assets.
2. Inside `deployments/`, create a folder for your Logic App (e.g., `MyLogicAppDeployment`).
3. Within that folder, create a subfolder named `pipelines/`.
4. Place your CI configuration YAML file (e.g., `CI-Pipeline.yml`) inside the `pipelines/` directory.

Example structure:

```plaintext
deployments/
â””â”€â”€ MyLogicAppDeployment/
    â””â”€â”€ pipelines/
        â””â”€â”€ CI-Pipeline.yml
```

> This structure promotes separation of concerns, simplifies CI configuration management, and scales well for multiple workflows or environments.

---

## Creating the Azure DevOps Pipeline (YAML)

Follow these steps to create your `azure-pipelines.yml` file:

### 1. Define the Trigger

Specify which branches will trigger the pipeline:

```yaml
trigger:
  branches:
    include:
      - main              # Run pipeline on push to main branch
      - devFeatureBranch  # Run pipeline on push to feature branches
```

### 2. Define the Build Agent

Select a Microsoft-hosted agent with the latest Windows environment:

```yaml
pool:
  vmImage: 'windows-latest'  # Latest Windows VM for build/test
```

### 3. Set Up the .NET SDK

Install the required .NET SDK to ensure the correct build environment:

```yaml
steps:
- task: UseDotNet@2
  displayName: 'Install .NET SDK'
  inputs:
    packageType: 'sdk'
    version: '6.x'  # Adjust to your projectâ€™s .NET version
```

### 4. Restore Dependencies

Restore all project dependencies to ensure necessary packages are available:

```yaml
- script: dotnet restore
  displayName: 'Restore NuGet Packages'
  workingDirectory: ./Tests
```

### 5. Build the Project

Compile the solution in Release mode. The `--no-restore` flag is used since dependencies have been restored:

```yaml
- script: dotnet build --configuration Release --no-restore
  displayName: 'Build Solution'
  workingDirectory: ./Tests
```

### 6. Run Unit Tests Using VSTest@3

Configure the pipeline to run your unit tests:

```yaml
- task: VSTest@3
  displayName: 'Run Unit Tests'
  inputs:
    testSelector: 'testAssemblies'
    testAssemblyVer2: '**/*Tests.dll'    # Runs all test assemblies
    searchFolder: '$(Build.SourcesDirectory)/LogicAppProject/tests'  # Update as necessary
    codeCoverageEnabled: true
    platform: '$(BuildPlatform)'
    configuration: '$(BuildConfiguration)'
```

**Explanation:**

- **Test Selection:** Uses a wildcard (`*Tests.dll`) to discover test assemblies.
- **Search Folder:** Specifies where test assemblies are located.
- **Code Coverage:** Enables code coverage reporting to provide insight into test coverage.

### 7. Publish Test Results

Finally, publish the test results so that they appear in the Azure DevOps pipeline summary:

```yaml
- task: PublishTestResults@2
  displayName: 'Publish Test Results'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/TestResults/*.trx'
    mergeTestResults: true
```

---
